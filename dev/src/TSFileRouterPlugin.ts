import { Plugin } from 'vite';
import { ResolvedConfig } from 'vite';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';
import { get } from 'http';

// Define a type-safe route interface
interface RouteConfig {
  path: string; // The path of the route (e.g. "/about", "/posts/:postId")
}

export default function RouteManifestPlugin(): Plugin {
  const outputDir = path.resolve(process.cwd(), 'src');
  const manifestFile = path.join(outputDir, 'routeManifest.ts');
  let routes: RouteConfig[];

  return {
    name: 'vite-plugin-route-manifest',
    async configResolved(config) {
      if (config.router.name === 'client') {
        const router = config?.app.getRouter('client').internals.routes;
        if (!router) throw new Error('Could not get router from vinxi app');
        routes = await router.getRoutes();
        console.log('Route manifest plugin loaded. Routes loaded from app');
      }
    },
    async buildStart(config) {
      console.log('config build', config);
      if (!routes) throw new Error('Could not get router from vinxi app');
      await generateManifest(routes);
    },
    async handleHotUpdate(ctx) {
      // Watch the route configuration or changes to the route files.
      if (
        (ctx.file.endsWith('.ts') || ctx.file.endsWith('.tsx')) &&
        !ctx.file.endsWith('routeManifest.ts') &&
        !ctx.file.endsWith('TSFileRouterPlugin.ts')
      ) {
        console.log(`File changed: ${ctx.file}. Regenerating manifest.`);

        await generateManifest(routes);
      }
    },
  };

  async function generateManifest(routes: RouteConfig[]) {
    const routeMap = createRouteObject(routes);
    const content = generateTypeSafeRouteFile(routeMap);

    // Create the output directory if it doesn't exist
    await mkdir(outputDir, { recursive: true });

    // Write the type-safe manifest file
    await writeFile(manifestFile, content, 'utf-8');
    console.log(`Route manifest generated at ${manifestFile}`);
  }

  function createRouteObject(routes: RouteConfig[]) {
    const routeObject = {};
    const filteredRoutes = routes.filter(r => !r.path.startsWith('/*')); //ignore catch all at toplevel
    filteredRoutes.forEach(route => {
      const path = route.path.replace(/\(.*?\)/gi, '').replace(/\/\//gi, '/');
      const parts = path.split('/').filter(Boolean); // Split by `/` and remove empty parts
      let currentLevel: any = routeObject;
      let prevPart: string;
      parts.forEach((part, index) => {
        // Handle dynamic segments (e.g., :postId -> [index])
        if (part.startsWith(':') || part.startsWith('*')) {
          console.log('part', part, prevPart, parts[index - 1]);
          part = ':' + parts[index - 1]?.replace(':', ''); // Allow string or number for dynamic parts
          //part = getDynamicProxy(prevPart);
        }

        if (!currentLevel[part]) {
          // For the last part of the path, set the actual string path value
          currentLevel[part] = index === parts.length - 1 ? path : {};
        }
        prevPart = part;
        currentLevel = currentLevel[part];
      });
    });

    return routeObject;
  }

  function generateTypeSafeRouteFile(routeMap: Record<string, any>) {
    // Generate routes with proxy objects for dynamic parts

    console.log(JSON.stringify(routeMap, null));
    //console.log(routeMap);
    let routeTree = JSON.stringify(routeMap, null);
    // .replace(
    //   /\{['"]\:(.*?)['"].*?\}+/gim,
    //   getDynamicProxy('$1'),
    // );
    if (!routeTree.endsWith('}')) routeTree += '}';

    //replace placeholders in () and then remove double //

    return `
    // This file is generated by the routeManifestPlugin. Do not edit manually.
    export const Routes =
      ${routeTree};


    export type RoutePaths = keyof typeof Routes;
    `;
  }
}

function getDynamicProxy(parent: string) {
  const proxy = `new Proxy(
    {},
    {
      get: (target, prop) => {
        return \`/${parent}/\${String(prop)}\`;
      },
    },
  )`;

  return proxy;
}
